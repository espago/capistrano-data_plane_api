# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `strings` gem.
# Please instead update this file by running `bin/tapioca gem strings`.


# source://strings//lib/strings/align.rb#6
module Strings
  private

  # Align text within the width.
  #
  # @api public
  # @see Strings::Align#align
  #
  # source://strings//lib/strings.rb#18
  def align(*args, **kws); end

  # Align text with the width.
  #
  # @api public
  # @see Strings::Align#align
  #
  # source://strings//lib/strings.rb#38
  def align_center(*args); end

  # Align text left within the width.
  #
  # @api public
  # @see Strings::Align#align_left
  #
  # source://strings//lib/strings.rb#28
  def align_left(*args); end

  # Align text with the width.
  #
  # @api public
  # @see Strings::Align#align
  #
  # source://strings//lib/strings.rb#48
  def align_right(*args); end

  # Check if string contains ANSI codes
  #
  # @api public
  # @return [Boolean]
  # @see Strings::ANSI#ansi?
  #
  # source://strings//lib/strings.rb#58
  def ansi?(string); end

  # Remove any line break characters from the text
  #
  # @api public
  # @see Strings::Fold#fold
  #
  # source://strings//lib/strings.rb#68
  def fold(*args); end

  # Apply padding to multiline text with ANSI codes
  #
  # @api public
  # @see Strings::Pad#pad
  #
  # source://strings//lib/strings.rb#78
  def pad(*args); end

  # Remove ANSI codes from the string
  #
  # @api public
  # @see Strings::ANSI#sanitize
  #
  # source://strings//lib/strings.rb#88
  def sanitize(string); end

  # Truncate a text at a given length
  #
  # @api public
  # @see Strings::Truncate#truncate
  #
  # source://strings//lib/strings.rb#98
  def truncate(*args); end

  # Wrap a text into lines at wrap length
  #
  # @api public
  # @see Strings::Wrap#wrap
  #
  # source://strings//lib/strings.rb#108
  def wrap(*args); end

  class << self
    # Align text within the width.
    #
    # @api public
    # @see Strings::Align#align
    #
    # source://strings//lib/strings.rb#18
    def align(*args, **kws); end

    # Align text with the width.
    #
    # @api public
    # @see Strings::Align#align
    #
    # source://strings//lib/strings.rb#38
    def align_center(*args); end

    # Align text left within the width.
    #
    # @api public
    # @see Strings::Align#align_left
    #
    # source://strings//lib/strings.rb#28
    def align_left(*args); end

    # Align text with the width.
    #
    # @api public
    # @see Strings::Align#align
    #
    # source://strings//lib/strings.rb#48
    def align_right(*args); end

    # Check if string contains ANSI codes
    #
    # @api public
    # @return [Boolean]
    # @see Strings::ANSI#ansi?
    #
    # source://strings//lib/strings.rb#58
    def ansi?(string); end

    # Remove any line break characters from the text
    #
    # @api public
    # @see Strings::Fold#fold
    #
    # source://strings//lib/strings.rb#68
    def fold(*args); end

    # Apply padding to multiline text with ANSI codes
    #
    # @api public
    # @see Strings::Pad#pad
    #
    # source://strings//lib/strings.rb#78
    def pad(*args); end

    # Remove ANSI codes from the string
    #
    # @api public
    # @see Strings::ANSI#sanitize
    #
    # source://strings//lib/strings.rb#88
    def sanitize(string); end

    # Truncate a text at a given length
    #
    # @api public
    # @see Strings::Truncate#truncate
    #
    # source://strings//lib/strings.rb#98
    def truncate(*args); end

    # Wrap a text into lines at wrap length
    #
    # @api public
    # @see Strings::Wrap#wrap
    #
    # source://strings//lib/strings.rb#108
    def wrap(*args); end
  end
end

# Responsible for text alignment
#
# source://strings//lib/strings/align.rb#8
module Strings::Align
  private

  # Aligns text within the width.
  #
  # If the text is greater than the width then unmodified
  # string is returned.
  #
  # @api public
  # @example
  #   text = "the madness of men"
  #
  #   Strings::Align.align(text, 22, direction: :left)
  #   # => "the madness of men      "
  #
  #   Strings::Align.align(text, 22, direction: :center)
  #   # => "   the madness of men   "
  #
  #   Strings::Align(text, 22, direction: :right)
  #   # => "      the madness of men"
  #
  #   Strings::Align.align(text, 22, direction: :center, fill: "*")
  #   # => "***the madness of men***"
  # @param text [String] the text to align lines of
  # @param width [Integer] the maximum width to align to
  #
  # source://strings//lib/strings/align.rb#39
  def align(text, width, direction: T.unsafe(nil), **options); end

  # Centers text within the width
  #
  # @api public
  # @return [String]
  #
  # source://strings//lib/strings/align.rb#86
  def align_center(text, width, fill: T.unsafe(nil), separator: T.unsafe(nil)); end

  # Aligns text to the left at given length
  #
  # @api public
  # @return [String]
  #
  # source://strings//lib/strings/align.rb#66
  def align_left(text, width, fill: T.unsafe(nil), separator: T.unsafe(nil)); end

  # Aligns text to the right at given length
  #
  # @api public
  # @return [String]
  #
  # source://strings//lib/strings/align.rb#108
  def align_right(text, width, fill: T.unsafe(nil), separator: T.unsafe(nil)); end

  # Visible width of a string
  #
  # @api private
  #
  # source://strings//lib/strings/align.rb#142
  def display_width(string); end

  # Enumerate text line by line
  #
  # @api private
  # @param text [String]
  # @return [String]
  #
  # source://strings//lib/strings/align.rb#130
  def each_line(text, separator); end

  # Convert direction to method name
  #
  # @api private
  #
  # source://strings//lib/strings/align.rb#50
  def to_alignment(direction); end

  class << self
    # Aligns text within the width.
    #
    # If the text is greater than the width then unmodified
    # string is returned.
    #
    # @api public
    # @example
    #   text = "the madness of men"
    #
    #   Strings::Align.align(text, 22, direction: :left)
    #   # => "the madness of men      "
    #
    #   Strings::Align.align(text, 22, direction: :center)
    #   # => "   the madness of men   "
    #
    #   Strings::Align(text, 22, direction: :right)
    #   # => "      the madness of men"
    #
    #   Strings::Align.align(text, 22, direction: :center, fill: "*")
    #   # => "***the madness of men***"
    # @param text [String] the text to align lines of
    # @param width [Integer] the maximum width to align to
    #
    # source://strings//lib/strings/align.rb#39
    def align(text, width, direction: T.unsafe(nil), **options); end

    # Centers text within the width
    #
    # @api public
    # @return [String]
    #
    # source://strings//lib/strings/align.rb#86
    def align_center(text, width, fill: T.unsafe(nil), separator: T.unsafe(nil)); end

    # Aligns text to the left at given length
    #
    # @api public
    # @return [String]
    #
    # source://strings//lib/strings/align.rb#66
    def align_left(text, width, fill: T.unsafe(nil), separator: T.unsafe(nil)); end

    # Aligns text to the right at given length
    #
    # @api public
    # @return [String]
    #
    # source://strings//lib/strings/align.rb#108
    def align_right(text, width, fill: T.unsafe(nil), separator: T.unsafe(nil)); end

    # Visible width of a string
    #
    # @api private
    #
    # source://strings//lib/strings/align.rb#142
    def display_width(string); end

    # Enumerate text line by line
    #
    # @api private
    # @param text [String]
    # @return [String]
    #
    # source://strings//lib/strings/align.rb#130
    def each_line(text, separator); end

    # Convert direction to method name
    #
    # @api private
    #
    # source://strings//lib/strings/align.rb#50
    def to_alignment(direction); end
  end
end

# source://strings//lib/strings/align.rb#11
Strings::Align::LINE_BREAK = T.let(T.unsafe(nil), Regexp)

# source://strings//lib/strings/align.rb#9
Strings::Align::NEWLINE = T.let(T.unsafe(nil), String)

# source://strings//lib/strings/align.rb#10
Strings::Align::SPACE = T.let(T.unsafe(nil), String)

# source://strings//lib/strings/fold.rb#4
module Strings::Fold
  private

  # Fold a multiline text into a single line string
  #
  # @api public
  # @example
  #   fold("\tfoo \r\n\n bar") # => " foo  bar"
  # @param text [String]
  # @param separator [String] the separators to be removed from the text, default: (\r\n+|\r+|\n+|\t+)
  # @return [String]
  #
  # source://strings//lib/strings/fold.rb#20
  def fold(text, separator = T.unsafe(nil)); end

  class << self
    # Fold a multiline text into a single line string
    #
    # @api public
    # @example
    #   fold("\tfoo \r\n\n bar") # => " foo  bar"
    # @param text [String]
    # @param separator [String] the separators to be removed from the text, default: (\r\n+|\r+|\n+|\t+)
    # @return [String]
    #
    # source://strings//lib/strings/fold.rb#20
    def fold(text, separator = T.unsafe(nil)); end
  end
end

# source://strings//lib/strings/fold.rb#5
Strings::Fold::LINE_BREAK = T.let(T.unsafe(nil), String)

# Responsible for text padding
#
# source://strings//lib/strings/pad.rb#10
module Strings::Pad
  private

  # Calculate visible string width
  #
  # @api private
  # @return [Integer]
  #
  # source://strings//lib/strings/pad.rb#91
  def display_width(string); end

  # Determine maximum length for all multiline content
  #
  # @api private
  # @param text [String]
  # @param separator [String]
  # @return [Integer]
  #
  # source://strings//lib/strings/pad.rb#80
  def max_line_length(text, separator); end

  # Apply padding to multiline text with ANSI codes
  #
  # @api private
  # @example
  #   text = "Ignorance is the parent of fear."
  #
  #   Strings::Pad.pad(text, [1, 2], fill: "*")
  #   # =>
  #   # "************************************\n"
  #   # "**Ignorance is the parent of fear.**\n"
  #   # "************************************\n"
  # @param text [String] the text to pad out
  # @param padding [Integer, Array[Integer]] the padding to apply to text
  # @return [String]
  #
  # source://strings//lib/strings/pad.rb#34
  def pad(text, padding, fill: T.unsafe(nil), separator: T.unsafe(nil)); end

  # Apply padding to left and right side of string
  #
  # @api private
  # @param text [String]
  # @return [String]
  #
  # source://strings//lib/strings/pad.rb#67
  def pad_around(text, padding, fill: T.unsafe(nil)); end

  class << self
    # Calculate visible string width
    #
    # @api private
    # @return [Integer]
    #
    # source://strings//lib/strings/pad.rb#91
    def display_width(string); end

    # Determine maximum length for all multiline content
    #
    # @api private
    # @param text [String]
    # @param separator [String]
    # @return [Integer]
    #
    # source://strings//lib/strings/pad.rb#80
    def max_line_length(text, separator); end

    # Apply padding to multiline text with ANSI codes
    #
    # @api private
    # @example
    #   text = "Ignorance is the parent of fear."
    #
    #   Strings::Pad.pad(text, [1, 2], fill: "*")
    #   # =>
    #   # "************************************\n"
    #   # "**Ignorance is the parent of fear.**\n"
    #   # "************************************\n"
    # @param text [String] the text to pad out
    # @param padding [Integer, Array[Integer]] the padding to apply to text
    # @return [String]
    #
    # source://strings//lib/strings/pad.rb#34
    def pad(text, padding, fill: T.unsafe(nil), separator: T.unsafe(nil)); end

    # Apply padding to left and right side of string
    #
    # @api private
    # @param text [String]
    # @return [String]
    #
    # source://strings//lib/strings/pad.rb#67
    def pad_around(text, padding, fill: T.unsafe(nil)); end
  end
end

# source://strings//lib/strings/pad.rb#13
Strings::Pad::LINE_BREAK = T.let(T.unsafe(nil), Regexp)

# source://strings//lib/strings/pad.rb#11
Strings::Pad::NEWLINE = T.let(T.unsafe(nil), String)

# source://strings//lib/strings/pad.rb#12
Strings::Pad::SPACE = T.let(T.unsafe(nil), String)

# A class responsible for parsing padding value
#
# Used internally by {Strings::Pad}
#
# @api private
#
# source://strings//lib/strings/padder.rb#9
class Strings::Padder
  # Initialize a Padder
  #
  # @api public
  # @return [Padder] a new instance of Padder
  #
  # source://strings//lib/strings/padder.rb#60
  def initialize(padding); end

  # Bottom padding
  #
  # @api public
  # @return [Integer]
  #
  # source://strings//lib/strings/padder.rb#107
  def bottom; end

  # Set bottom padding
  #
  # @api public
  # @param value [Integer]
  # @return [nil]
  #
  # source://strings//lib/strings/padder.rb#118
  def bottom=(value); end

  # Check if padding is set
  #
  # @api public
  # @return [Boolean]
  #
  # source://strings//lib/strings/padder.rb#147
  def empty?; end

  # Left padding
  #
  # @api public
  # @return [Integer]
  #
  # source://strings//lib/strings/padder.rb#127
  def left; end

  # Set left padding
  #
  # @api public
  # @param value [Integer]
  # @return [nil]
  #
  # source://strings//lib/strings/padder.rb#138
  def left=(value); end

  # Padding
  #
  # @api private
  # @return [Array[Integer]]
  #
  # source://strings//lib/strings/padder.rb#55
  def padding; end

  # Right padding
  #
  # @api public
  # @return [Integer]
  #
  # source://strings//lib/strings/padder.rb#89
  def right; end

  # Set right padding
  #
  # @api public
  # @param value [Integer]
  #
  # source://strings//lib/strings/padder.rb#98
  def right=(value); end

  # String represenation of this padder with padding values
  #
  # @api public
  # @return [String]
  #
  # source://strings//lib/strings/padder.rb#156
  def to_s; end

  # Top padding
  #
  # @api public
  # @return [Integer]
  #
  # source://strings//lib/strings/padder.rb#69
  def top; end

  # Set top padding
  #
  # @api public
  # @param value [Integer]
  # @return [nil]
  #
  # source://strings//lib/strings/padder.rb#80
  def top=(value); end

  class << self
    # Convert value to 4 element array
    #
    # @api private
    # @return [Array[Integer]] the 4 element padding array
    #
    # source://strings//lib/strings/padder.rb#38
    def convert_to_ary(value); end

    # Parse padding options
    #
    # Turn possible values into 4 element array
    #
    # @api public
    # @example
    #   padder = TTY::Table::Padder.parse(5)
    #   padder.padding # => [5, 5, 5, 5]
    # @param value [Object]
    # @return [TTY::Padder] the new padder with padding values
    #
    # source://strings//lib/strings/padder.rb#26
    def parse(value = T.unsafe(nil)); end
  end
end

# @api private
#
# source://strings//lib/strings/padder.rb#10
class Strings::Padder::ParseError < ::ArgumentError; end

# A module responsible for text truncation
#
# source://strings//lib/strings/truncate.rb#9
module Strings::Truncate
  private

  # Visible width of a string
  #
  # @api private
  #
  # source://strings//lib/strings/truncate.rb#102
  def display_width(string); end

  # Perform actual shortening of the text
  #
  # @api private
  # @return [String]
  #
  # source://strings//lib/strings/truncate.rb#71
  def shorten(original_chars, chars, length_without_trailing); end

  # @api private
  #
  # source://strings//lib/strings/truncate.rb#94
  def to_chars(text); end

  # Truncate a text at a given length (defualts to 30)
  #
  # @api public
  # @example
  #   text = "The sovereignest thing on earth is parmacetti for an inward bruise."
  #
  #   Strings::Truncate.truncate(text)
  #   # => "The sovereignest thing on ea…"
  #
  #   Strings::Truncate.truncate(text, 20)
  #   # => "The sovereignest t…"
  #
  #   Strings::Truncate.truncate(text, 20, separator: " " )
  #   # => "The sovereignest…"
  #
  #   Strings::Truncate.truncate(text, 40, trailing: "... (see more)" )
  #   # => "The sovereignest thing on... (see more)"
  # @param text [String] the text to be truncated
  # @param truncate_at [Integer] the width at which to truncate the text
  # @param options [Hash] @option options [Symbol] :separator the character for splitting words
  #   @option options [Symbol] :trailing  the character for ending sentence
  #
  # source://strings//lib/strings/truncate.rb#42
  def truncate(text, truncate_at = T.unsafe(nil), options = T.unsafe(nil)); end

  class << self
    # Visible width of a string
    #
    # @api private
    #
    # source://strings//lib/strings/truncate.rb#102
    def display_width(string); end

    # Perform actual shortening of the text
    #
    # @api private
    # @return [String]
    #
    # source://strings//lib/strings/truncate.rb#71
    def shorten(original_chars, chars, length_without_trailing); end

    # @api private
    #
    # source://strings//lib/strings/truncate.rb#94
    def to_chars(text); end

    # Truncate a text at a given length (defualts to 30)
    #
    # @api public
    # @example
    #   text = "The sovereignest thing on earth is parmacetti for an inward bruise."
    #
    #   Strings::Truncate.truncate(text)
    #   # => "The sovereignest thing on ea…"
    #
    #   Strings::Truncate.truncate(text, 20)
    #   # => "The sovereignest t…"
    #
    #   Strings::Truncate.truncate(text, 20, separator: " " )
    #   # => "The sovereignest…"
    #
    #   Strings::Truncate.truncate(text, 40, trailing: "... (see more)" )
    #   # => "The sovereignest thing on... (see more)"
    # @param text [String] the text to be truncated
    # @param truncate_at [Integer] the width at which to truncate the text
    # @param options [Hash] @option options [Symbol] :separator the character for splitting words
    #   @option options [Symbol] :trailing  the character for ending sentence
    #
    # source://strings//lib/strings/truncate.rb#42
    def truncate(text, truncate_at = T.unsafe(nil), options = T.unsafe(nil)); end
  end
end

# source://strings//lib/strings/truncate.rb#12
Strings::Truncate::DEFAULT_LENGTH = T.let(T.unsafe(nil), Integer)

# source://strings//lib/strings/truncate.rb#10
Strings::Truncate::DEFAULT_TRAILING = T.let(T.unsafe(nil), String)

# source://strings//lib/strings/version.rb#4
Strings::VERSION = T.let(T.unsafe(nil), String)

# source://strings//lib/strings/wrap.rb#8
module Strings::Wrap
  private

  # Visible width of a string
  #
  # @api private
  #
  # source://strings//lib/strings/wrap.rb#170
  def display_width(string); end

  # Format line to be maximum of wrap_at length
  #
  # @api private
  # @param text_line [String] the line to format
  # @param wrap_at [Integer] the maximum length to wrap the line
  # @return [Array[String]] the wrapped lines
  #
  # source://strings//lib/strings/wrap.rb#46
  def format_line(text_line, wrap_at, ansi_stack); end

  # Insert ANSI code into string
  #
  # Check if there are any ANSI states, if present
  # insert ANSI codes at given positions unwinding the stack.
  #
  # @api private
  # @param string [String] the string to insert ANSI codes into
  # @param ansi_stack [Array[Array[String, Integer]]] the ANSI codes to apply
  # @return [String]
  #
  # source://strings//lib/strings/wrap.rb#131
  def insert_ansi(string, ansi_stack = T.unsafe(nil)); end

  # Wrap a text into lines no longer than wrap_at length.
  # Preserves existing lines and existing word boundaries.
  #
  # @api public
  # @example
  #   Strings::Wrap.wrap("Some longish text", 8)
  #   # => "Some \nlongish \ntext"
  #
  # source://strings//lib/strings/wrap.rb#23
  def wrap(text, wrap_at = T.unsafe(nil), separator: T.unsafe(nil)); end

  class << self
    # Visible width of a string
    #
    # @api private
    #
    # source://strings//lib/strings/wrap.rb#170
    def display_width(string); end

    # Format line to be maximum of wrap_at length
    #
    # @api private
    # @param text_line [String] the line to format
    # @param wrap_at [Integer] the maximum length to wrap the line
    # @return [Array[String]] the wrapped lines
    #
    # source://strings//lib/strings/wrap.rb#46
    def format_line(text_line, wrap_at, ansi_stack); end

    # Insert ANSI code into string
    #
    # Check if there are any ANSI states, if present
    # insert ANSI codes at given positions unwinding the stack.
    #
    # @api private
    # @param string [String] the string to insert ANSI codes into
    # @param ansi_stack [Array[Array[String, Integer]]] the ANSI codes to apply
    # @return [String]
    #
    # source://strings//lib/strings/wrap.rb#131
    def insert_ansi(string, ansi_stack = T.unsafe(nil)); end

    # Wrap a text into lines no longer than wrap_at length.
    # Preserves existing lines and existing word boundaries.
    #
    # @api public
    # @example
    #   Strings::Wrap.wrap("Some longish text", 8)
    #   # => "Some \nlongish \ntext"
    #
    # source://strings//lib/strings/wrap.rb#23
    def wrap(text, wrap_at = T.unsafe(nil), separator: T.unsafe(nil)); end
  end
end

# source://strings//lib/strings/wrap.rb#9
Strings::Wrap::DEFAULT_WIDTH = T.let(T.unsafe(nil), Integer)

# source://strings//lib/strings/wrap.rb#12
Strings::Wrap::LINE_BREAK = T.let(T.unsafe(nil), Regexp)

# source://strings//lib/strings/wrap.rb#13
Strings::Wrap::LINE_BREAKS = T.let(T.unsafe(nil), String)

# source://strings//lib/strings/wrap.rb#10
Strings::Wrap::NEWLINE = T.let(T.unsafe(nil), String)

# source://strings//lib/strings/wrap.rb#11
Strings::Wrap::SPACE = T.let(T.unsafe(nil), String)
